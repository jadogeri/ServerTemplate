Testcontainers for Node.js can be used to set up a disposable MongoDB instance for end-to-end (E2E) testing of a JavaScript application, including its controllers. 
1. Setting up Testcontainers and MongoDB: 
First, install the necessary packages: 
npm install --save-dev testcontainers @testcontainers/mongodb mongodb

Then, in your E2E test setup (e.g., a beforeAll hook in Jest), you can start a MongoDB container: 
const { GenericContainer } = require("testcontainers");
const { MongoClient } = require("mongodb");

let mongoContainer;
let mongoClient;
let db;

beforeAll(async () => {
  mongoContainer = await new GenericContainer("mongo:latest")
    .withExposedPorts(27017)
    .start();

  const mongoUri = `mongodb://localhost:${mongoContainer.getMappedPort(27017)}/testdb`;
  mongoClient = new MongoClient(mongoUri);
  await mongoClient.connect();
  db = mongoClient.db();
});

afterAll(async () => {
  await mongoClient.close();
  await mongoContainer.stop();
});

2. Interacting with the MongoDB instance in your E2E tests: 
Within your E2E tests, you can now interact with the db object (or your application's MongoDB client, if it uses a dynamic connection string) to perform operations on the database. 
Example E2E test for a MongoDB-backed controller: 
Assume you have a UserController that interacts with a users collection in MongoDB. 
// userController.js
const { ObjectId } = require('mongodb');

class UserController {
  constructor(db) {
    this.usersCollection = db.collection('users');
  }

  async createUser(userData) {
    const result = await this.usersCollection.insertOne(userData);
    return result.insertedId;
  }

  async getUserById(id) {
    const user = await this.usersCollection.findOne({ _id: new ObjectId(id) });
    return user;
  }
}

module.exports = UserController;

Your E2E test might look like this: 
// user.e2e.test.js
const request = require('supertest'); // Assuming you use Supertest for API testing
const app = require('../src/app'); // Your Express/Koa app
const UserController = require('../src/userController');

describe('User Controller E2E', () => {
  let userController;

  beforeEach(async () => {
    // Clear the collection before each test
    await db.collection('users').deleteMany({});
    userController = new UserController(db); // Initialize controller with the test DB
  });

  it('should create a new user and retrieve it', async () => {
    const userData = { name: 'John Doe', email: 'john.doe@example.com' };

    // Simulate API call to create user
    const createResponse = await request(app)
      .post('/users')
      .send(userData)
      .expect(201); // Assuming 201 Created on success

    const userId = createResponse.body.id; // Get the ID from the response

    // Verify user in the database directly (optional, but good for E2E)
    const storedUser = await userController.getUserById(userId);
    expect(storedUser).toMatchObject(userData);

    // Simulate API call to get user
    const getResponse = await request(app)
      .get(`/users/${userId}`)
      .expect(200);

    expect(getResponse.body).toMatchObject(userData);
  });

  // Add more E2E tests for other controller actions
});

Key Points for E2E Testing with Testcontainers: 

• Isolation: Each test run gets a fresh, isolated MongoDB container, preventing test interference. 
• Real Database Interaction: You are testing against a real MongoDB instance, not a mock, ensuring true E2E behavior. 
• Cleanup: The afterAll hook ensures the container is stopped and cleaned up after all tests are complete. 
• Data Seeding/Cleanup: Use beforeEach to clear or seed data in your test database as needed for each test case. 

AI responses may include mistakes.

